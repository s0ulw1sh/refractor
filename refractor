#!/usr/bin/python3

__author__    = "Pavel Rid aka Soulwish"
__copyright__ = "Copyright (C) 2021 Pavel Rid | https://github.com/s0ulw1sh/refractor"
__license__   = "GPLv3 (GNU General Public License Version 3)"
__version__   = "1.0.0"

import sys
import os
import json
import argparse
import logging
import subprocess
from http.server import SimpleHTTPRequestHandler, HTTPServer
from base64 import standard_b64encode
from hashlib import sha1
from http import HTTPStatus
from string import Template

def defaultElmHtmlTemplate():
    return '''<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$title</title>
    $head
</head>
<body>
    <pre id="elm-mount"></pre>
    $footer
    $elmscript
    <script>
        $elmcode
    </script>
</body>
</html>
    '''

class Refractor(SimpleHTTPRequestHandler):

    args    = {}
    protocol_version = "HTTP/1.1"
    server_version = "refractor/" + __version__
    
    WS_MAGICK       = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
    WS_OPC_CONTINUE = 0x0
    WS_OPC_TEXT     = 0x1
    WS_OPC_BIN      = 0x2
    WS_OPC_CLOSE    = 0x8
    WS_OPC_PING     = 0x9
    WS_OPC_PONG     = 0xa

    def __init__(self, request=None, client_address=None, server=None):
        if request != None:
            super().__init__(request, client_address, server)
        else:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s [%(levelname)s] : %(message)s',
                datefmt='%Y-%m-%d %H:%M:%S')

            cli = argparse.ArgumentParser(
                                description='Refractor web server for Elm project')
            cli.add_argument('-H', '--host',
                                help     = 'The host of the server (localhost)',
                                required = False,
                                default  = 'localhost')
            cli.add_argument('-P', '--port',
                                help = 'The port of the server (8000)',
                                required = False,
                                default = 8000)
            cli.add_argument('-T', '--template',
                                help = 'HTML template, -T @ - prints the built-in template',
                                required = False,
                                default = '')
            cli.add_argument('-C', '--cmd',
                                help = 'Command',
                                required = False,
                                default = '')
            cli.add_argument('-S', '--style',
                                help = 'CSS Style file',
                                required = False,
                                default = '')
            cli.add_argument('-J', '--js',
                                help = 'JavaScript file',
                                required = False,
                                default = '')

            self.args      = cli.parse_args()
            self.args.cwd  = os.getcwd()
            self.args.cfg  = {
                'api'      :{},
                'elm'      :{},
                'template' :{},
                'commands' :{}
            }
            self.args.http = {}
            self.args.rpc  = {}

            if self.args.template == '@':
                print(defaultElmHtmlTemplate())
                sys.exit(0)

            self.args.elm  = os.path.isfile(os.path.join(self.args.cwd, 'elm.json'))

            if self.args.elm:

                elmstuffdir = os.path.join(self.args.cwd, 'elm-stuff')

                if not os.path.isdir(elmstuffdir):
                    try:
                        os.mkdir(elmstuffdir)
                    except OSError:
                        logging.error('creation of the directory `elm-stuff` failed')
                        sys.exit(-1)
                    except Exception as e:
                        logging.error(e)
                        sys.exit(-1)

            jsonrefract    = os.path.join(self.args.cwd, 'refract.json')

            if os.path.isfile(jsonrefract):
                try:
                    with open(jsonrefract) as f:
                        self.args.cfg = json.load(f)
                        f.close()
                except IOError:
                    logging.error('refract.json not accessible')
                except Exception as e:
                    logging.error(e)
                    sys.exit(-1)
            else:
                return

            if self.args.cmd != '':
                cwd  = os.getcwd()
                code = self.runCommand(self.args.cmd)
                os.chdir(cwd)
                sys.exit(code)

            if 'api' in self.args.cfg and isinstance(self.args.cfg['api'], dict):
                
                apilist = (self.args.cfg['api']['list']
                            if 'list' in self.args.cfg['api'] and
                            isinstance(self.args.cfg['api']['list'], list) else [])
                
                for item in apilist:
                    if isinstance(item, dict) and 'result' in item:
                        
                        if 'call' in item and isinstance(item['call'], str):
                            self.args.rpc[item['call']] = item['result']

                        if 'path' in item and isinstance(item['path'], str):
                            try:
                                methods, path = item['path'].split('::', maxsplit=2)
                                methods = methods.split(',')
                            except:
                                path    = item['path']
                                methods = ['ANY']

                            self.args.http[path.strip('/')] = {
                                'methods' : list(map(self.httpMethodToIndex, methods)),
                                'result'  : item['result']
                            }
            else:
                self.args.cfg['api'] = {}

    def runCommand(self, cmd):

        if 'commands' in self.args.cfg and isinstance(self.args.cfg['commands'], dict):
            if cmd in self.args.cfg['commands']:
                if isinstance(self.args.cfg['commands'][cmd], list) and len(self.args.cfg['commands'][cmd]) > 0:
                    if isinstance(self.args.cfg['commands'][cmd][0], str):
                        try:
                            out = subprocess.run(self.args.cfg['commands'][cmd], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                        except Exception as e:
                            logging.error(e)
                            return -1

                        print(out.stdout.decode('utf-8'))

                        return out.returncode
                    
                    elif isinstance(self.args.cfg['commands'][cmd][0], list):
                        output  = []
                        code    = 0
                        
                        for item in self.args.cfg['commands'][cmd]:
                            try:
                                out = subprocess.run(item, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                            except Exception as e:
                                logging.error(e)
                                return -1

                            output.append(out.stdout.decode('utf-8'))

                            code = out.returncode

                            if code != 0:
                                break

                        print('\n'.join(output))
                        return code

        logging.info('command `{}` not found'.format(cmd))
        return 0

    def runServer(self):

        with HTTPServer((self.args.host, self.args.port), Refractor) as httpd:
            httpd.allow_reuse_address = True
            httpd.args                = self.args

            logging.info('Starting refractor web server {}:{}\n'.format(self.args.host, self.args.port))

            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                pass
            except Exception as e:
                logging.error(e)

            httpd.server_close()
            logging.info('Stopping refractor web server\n')


     ##  ## ###### ###### ####
     ##  ## # ## #   ##    ##
     ##  ##   ##     ##    ##
     ##  ##   ##     ##    ##
     ##  ##   ##     ##    ##   #
     ##  ##   ##     ##    ##  ##
      ####   ####  ###### #######

    def httpDisableCache(self):
        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        self.send_header('Pragma', 'no-cache')
        self.send_header('Expires', '0')

    def httpSendJson(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-type', 'application/json')
        self.send_header('Content-Length', str(len(data)))
        self.httpDisableCache()
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode('utf-8'))

    def validPath(self, path):
        return len(path.strip().strip('/')) > 0

    def httpMethodToIndex(self, method):
        return {
            'ANY'    : 0,
            'GET'    : 1,
            'POST'   : 2,
            'PUT'    : 3,
            'PATCH'  : 4,
            'DELETE' : 5
        }.get(method.upper(), 0)


      ####  ##  ## #######  #### ###  ##
     ##  ## ##  ##  ##   # ##  ## ##  ##
    ##      ##  ##  ## #  ##      ## ##
    ##      ######  ####  ##      ####
    ##      ##  ##  ## #  ##      ## ##
     ##  ## ##  ##  ##   # ##  ## ##  ##
      ####  ##  ## #######  #### ###  ##

    def restCheckApi(self, method='GET'):
        apipath = (self.server.args.cfg['api']['rest']
                    if 'rest' in self.server.args.cfg['api'] else '/_api')

        if not isinstance(apipath, str):
            return False

        if self.path.startswith(apipath) and self.path != apipath:
            path = self.path.strip('/').strip(apipath)
            if path in self.server.args.http:
                method = self.httpMethodToIndex(method)
                if 0 in self.server.args.http[path]['methods'] or method in self.server.args.http[path]['methods']:
                    self.httpSendJson(self.server.args.http[path]['result'])
                else:
                    self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')
            else:
                self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')

            return True
        else:
            return False

    def wsCheckApi(self):
        wspath = (self.server.args.cfg['api']['ws']
                    if 'ws' in self.server.args.cfg['api'] else '/_api/ws')

        if not isinstance(wspath, str):
            return False

        if wspath == self.path:
            upgrade = self.headers.get('Upgrade', None)

            if upgrade and upgrade.lower().strip() == 'websocket':
                self.wsHandshake()
                self.wsReadMessages()
                return True
            else:
                self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')
                return True

        return False

    def rpcCheckApi(self):
        rpcpath = (self.server.args.cfg['api']['rpc']
                    if 'rpc' in self.server.args.cfg['api'] else '/_api/rpc')

        if not isinstance(rpcpath, str):
            return False

        if rpcpath == self.path:
            cnlen = int(self.headers.get('Content-Length', 0))
            
            if cnlen == 0:
                self.send_error(HTTPStatus.INTERNAL_SERVER_ERROR, 'Invalid content length')
                return True

            post_data = self.rfile.read(cnlen).decode('utf-8')

            try:
                rpcreq = json.loads(post_data)
            except Exception as e:
                rpcreq = False

            if not isinstance(rpcreq, dict) or rpcreq.get('id', None) is None:
                self.httpSendJson({
                    'jsonrpc' : '2.0',
                    'id'      : None,
                    'error'   : {'code': -32700, 'message':'Parse error'}
                })
                return True

            callid = rpcreq.get('id')
            method = rpcreq.get('method', None)

            if not isinstance(method, str) or method == '' or method not in self.server.args.rpc:
                self.httpSendJson({
                    'jsonrpc' : '2.0',
                    'id'      : callid,
                    'error'   : {'code': -32601, 'message':'Method not found'}
                })
                return True

            self.httpSendJson({
                'jsonrpc' : '2.0',
                'id'      : callid,
                'result'  : self.server.args.rpc[method]
            })

            return True

        return False


    def elmCheck(self):
        elmbasename  = os.path.basename(self.path)
        elmname, ext = os.path.splitext(elmbasename)

        if ext.lower() != '.elm':
            return False

        if not self.server.args.elm:
            return False

        elmpath = os.path.join(self.server.args.cwd, self.path.strip('/'))
        
        if not os.path.isfile(elmpath):
            self.send_error(HTTPStatus.NOT_FOUND, 'Elm File Not Found {}'.format(self.path))
            return True

        elmcmd   = 'elm'
        optimize = False

        if 'elm' in self.server.args.cfg and isinstance(self.server.args.cfg, dict):
            optimize = ('optimize' in self.server.args.cfg['elm'] and
                        isinstance(self.server.args.cfg['elm']['optimize'], bool) and
                        self.server.args.cfg['elm']['optimize'] == True)
            elmcmd   = self.server.args.cfg['elm'].get('path', 'elm')

        command = [elmcmd, 'make', elmpath]

        if optimize:
            command.append('--optimize')

        jsoutname = self.path.strip('/').replace('/', '_') + '.js'
        jsoutpath = os.path.join(self.server.args.cwd, 'elm-stuff', jsoutname)

        command.append('--output')
        command.append(jsoutpath)

        try:
            out = subprocess.run(command, capture_output=True, timeout=3)
        except Exception as e:
            self.send_error(HTTPStatus.INTERNAL_SERVER_ERROR, str(e))
            return True

        if out.returncode != 0:
            self.send_response(500)
            self.send_header('Content-type', 'text/plain')
            self.send_header('Content-Length', str(len(out.stderr)))
            self.send_header('Connection', 'close')
            self.end_headers()
            self.wfile.write(out.stderr)
            return True

        template = self.server.args.template
        head     = []
        footer   = []

        if 'template' in self.server.args.cfg and isinstance(self.server.args.cfg['template'], dict):
            template = (self.server.args.cfg['template']['path']
                        if 'path' in self.server.args.cfg['template'] and
                        isinstance(self.server.args.cfg['template']['path'], str) else self.server.args.template)
            head     = (self.server.args.cfg['template']['head'].copy()
                        if 'head' in self.server.args.cfg['template'] and
                        isinstance(self.server.args.cfg['template']['head'], list) else [])
            footer   = (self.server.args.cfg['template']['footer'].copy()
                        if 'footer' in self.server.args.cfg['template'] and
                        isinstance(self.server.args.cfg['template']['footer'], list) else [])

        if self.server.args.style != '':
            head.append('<link rel="stylesheet" href="{}">'.format(self.server.args.style))

        if self.server.args.js != '':
            footer.append('<script type="text/javascript" src="{}"></script>'.format(self.server.args.js))

        tmpdata = ''

        if template != '':
            if not template.startswith('/'):
                template = os.path.join(self.server.args.cwd, template)

            if os.path.isfile(template):
                try:
                    with open(template) as f:
                        tmpdata = f.read()
                        f.close()
                except IOError:
                    logging.error('{} not accessible'.format(template))
                    return True
                except Exception as e:
                    logging.error(e)
                    return True
        else:
            tmpdata = defaultElmHtmlTemplate()

        tempalte = Template(tmpdata)

        rendered = tempalte.safe_substitute(head = '\n'.join(head),
            footer    = '\n'.join(footer),
            title     = elmbasename,
            elmscript = '<script src="/elm-stuff/{}"></script>'.format(jsoutname),
            elmcode   = 'var elmapp = Elm.'+elmname+'.init( {node: document.getElementById("elm-mount")} );').encode('utf-8')

        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.send_header('Content-Length', str(len(rendered)))
        self.httpDisableCache()
        self.end_headers()

        self.wfile.write(rendered)

        return True

    ##  ## ###### ###### ######
    ##  ## # ## # # ## #  ##  ##
    ##  ##   ##     ##    ##  ##
    ######   ##     ##    #####
    ##  ##   ##     ##    ##
    ##  ##   ##     ##    ##
    ##  ##  ####   ####  ####

    def do_GET(self):
        self.path = self.path.split('?')[0]

        if self.wsCheckApi():
            return

        if self.restCheckApi('GET'):
            return

        if self.elmCheck():
            return

        super().do_GET()


    def do_POST(self):
        self.path = self.path.split('?')[0]

        if self.rpcCheckApi():
            return

        if self.restCheckApi('POST'):
            return

        self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')

    def do_PUT(self):
        self.path = self.path.split('?')[0]

        if self.restCheckApi('PUT'):
            return

        self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')

    def do_PATCH(self):
        self.path = self.path.split('?')[0]

        if self.restCheckApi('PATCH'):
            return

        self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')

    def do_DELETE(self):
        self.path = self.path.split('?')[0]

        if self.restCheckApi('DELETE'):
            return

        self.send_error(HTTPStatus.NOT_FOUND, 'Not Found')

    ##   ## ####### ######   ####    ###     #### ###  ## ####### ######
    ##   ##  ##   #  ##  ## ##  ##  ## ##   ##  ## ##  ##  ##   # # ## #
    ##   ##  ## #    ##  ## ##     ##   ## ##      ## ##   ## #     ##
    ## # ##  ####    #####   ####  ##   ## ##      ####    ####     ##
    #######  ## #    ##  ##     ## ##   ## ##      ## ##   ## #     ##
    ### ###  ##   #  ##  ## ##  ##  ## ##   ##  ## ##  ##  ##   #   ##
    ##   ## ####### ######   ####    ###     #### ###  ## #######  ####

    def wsHandshake(self):
        headers = self.headers

        key = bytes(headers['Sec-WebSocket-Key'], "utf-8") + bytes(self.WS_MAGICK, "utf-8")
        key = sha1(key).digest()
        key = standard_b64encode(key)

        try:
            self.send_response(101, 'Switching Protocols')
            self.send_header('Upgrade', 'websocket')
            self.send_header('Connection', 'Upgrade')
            self.send_header('Sec-WebSocket-Accept', key.decode("utf-8", "ignore"))
            self.end_headers()
        except Exception as e:
            return

        self.wsconnect = True

    def wsReadMessages(self):
        while self.wsconnect == True:
            try:
                self.wsNextMessage()
            except Exception as e:
                logging.error(e)
                self.wsClose()

    def wsNextMessage(self):
        try:
            self.opcode = ord(self.rfile.read(1)) & 0x0F
            msglen      = ord(self.rfile.read(1)) & 0x7F

            if msglen == 126:
                msglen = struct.unpack(">H", self.rfile.read(2))[0]
            elif msglen == 127:
                msglen = struct.unpack(">Q", self.rfile.read(8))[0]

            masks   = [byte for byte in self.rfile.read(4)]
            decoded = ''

            for char in self.rfile.read(msglen):
                decoded += chr(char ^ masks[len(decoded) % 4])

            self.message = []
            self.wsOnMessage(decoded)
        except Exception as e:
            if self.wsconnect:
                raise Exception(e)

    def wsOnMessage(self, message):
        if self.opcode == self.WS_OPC_CLOSE:
            self.wsconnect = False
            try:
                self.wsSendClose()
            except:
                pass
        elif self.opcode == self.WS_OPC_PING:
            self.wsSendMessage(self.WS_OPC_PONG, message)
        elif self.opcode == self.WS_OPC_PONG:
            pass
        elif self.opcode == self.WS_OPC_BIN:
            self.message = []
        elif self.opcode == self.WS_OPC_CONTINUE:
            self.message.append(message)
        elif self.opcode == self.WS_OPC_TEXT:
            self.message.append(message)
            
            try:
                rpcreq = json.loads(''.join(self.message))
            except Exception as e:
                rpcreq = False

            if not isinstance(rpcreq, dict) or rpcreq.get('id', None) is None:
                self.wsSendJsonMessage(self.WS_OPC_TEXT, {
                    'jsonrpc' : '2.0',
                    'id'      : None,
                    'error'   : {'code': -32700, 'message':'Parse error'}
                })
                self.message = []
                return

            callid = rpcreq.get('id')
            method = rpcreq.get('method', None)

            if not isinstance(method, str) or method == '' or method not in self.server.args.rpc:
                self.wsSendJsonMessage(self.WS_OPC_TEXT, {
                    'jsonrpc' : '2.0',
                    'id'      : callid,
                    'error'   : {'code': -32601, 'message':'Method not found'}
                })
                self.message = []
                return

            self.wsSendJsonMessage(self.WS_OPC_TEXT, {
                'jsonrpc' : '2.0',
                'id'      : callid,
                'result'  : self.server.args.rpc[method]
            })

            self.message = []

    def wsSendMessage(self, opcode, message):
        try:
            self.request.send((0x80 + opcode).to_bytes(1, 'big'))
            length = len(message)
            if length <= 125:
                self.request.send(length.to_bytes(1, 'big'))
            elif length >= 126 and length <= 65535:
                self.request.send(126)
                self.request.send(struct.pack(">H", length))
            else:
                self.request.send(127)
                self.request.send(struct.pack(">Q", length))
            if length > 0:
                self.request.send(message)
        except Exception as e:
            self.wsClose()

    def wsSendJsonMessage(self, opcode, jsonmsg):
        self.wsSendMessage(opcode, json.dumps(jsonmsg).encode('utf-8'))

    def wsClose(self):
        try:
            if self.wsconnect:
                self.wsconnect = False
                try: 
                    self.wsSendClose()
                except:
                    pass
        finally:
            pass

    def wsSendClose(self):
        msg = bytearray()
        msg.append(0x80 + self.WS_OPC_CLOSE)
        msg.append(0x00)
        self.request.send(msg)

    def onWsMessage(self):
        pass

if __name__ == '__main__':
    app = Refractor()
    app.runServer()